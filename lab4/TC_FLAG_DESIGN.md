# Как итеративный DNS-резолвер работает с большими ответами (TC-флаг)


## Суть проблемы: По умолчанию DNS-запросы идут по UDP, где размер пакета жестко ограничен 512 байтами. Этого хватает для большинства записей (A, MX), но не для "тяжелых" — длинных TXT, ключей DNSSEC (DNSKEY) или больших наборов записей.

## Механизм: Если DNS-сервер не может уместить весь ответ в 512 байт, он делает две вещи:

Обрезает пакет.

Устанавливает в заголовке специальный флаг TC (Truncated), что означает "ответ усечен".

Увидев этот флаг, клиент (наш резолвер) обязан повторить тот же самый запрос, но уже по TCP. В TCP нет такого жесткого лимита на размер одного пакета, что позволяет получить полный ответ.

Как это выглядит в коде резолвера:

На каждом шаге (опрос корневого сервера, сервера домена и т.д.) резолвер действует по одной и той же схеме:

Пробуем UDP (основной способ):

Формируем DNS-запрос.

Отправляем его на сервер по UDP с таймаутом (например, 2-3 секунды).

Получаем ответ.

Анализируем ответ:

Смотрим на код результата (RCODE). Если это NXDOMAIN (домен не найден) или другая ошибка — сразу возвращаем её.

Смотрим на флаг TC. Это ключевой момент.

Если TC = 0 (не установлен):

Значит, ответ полный. Используем его и идем дальше.

Если TC = 1 (флаг установлен):

Логируем событие (для отладки): "Ответ усечен, перехожу на TCP к серверу X".

Устанавливаем TCP-соединение с тем же сервером.

Отправляем тот же самый запрос, но с важным нюансом: перед самими данными запроса мы отправляем 2 байта длины (в сетевом порядке байт). Это требование протокола DNS поверх TCP.

Читаем ответ: сначала 2 байта длины, затем ровно столько байт данных, сколько указано.

Разбираем уже этот, полный, TCP-ответ.

Возвращаем результат:

Если TCP-запрос успешен — отдаем распарсенные данные.

Если TCP не удался (сеть упала, таймаут) — возвращаем ошибку выше, чтобы резолвер мог попробовать другой сервер из списка.

Простыми словами, алгоритм такой:

text
ответ = отправить_запрос_по_udp(сервер, запрос)
если (ответ.усечен) {
    сказать("Нужно больше места! Переключаюсь на TCP.");
    ответ = отправить_запрос_по_tcp(сервер, запрос)
}
вернуть ответ
Важные технические детали при работе с TCP:

Формат: [2 байта длины][DNS-пакет]. Все отправляется и читается как один непрерывный блок.

Надежность: Нужно аккуратно читать сокет, чтобы гарантированно получить все байты ответа (recv_all).

Лимиты: В учебных проектах часто ставят разумный лимит (например, 4 КБ), но стандарт позволяет получать ответы до 64 КБ.

Зачем это всё нужно?
Этот механизм обеспечивает надежность и полноту данных. Без него резолвер не смог бы получать большие, но критически важные записи (например, для проверки подписи DNSSEC), что ломало бы безопасность или работу некоторых сервисов. Отладка по логам (когда видишь "TC flag set, retrying over TCP") помогает понять, почему запрос шел дольше обычного и что все работает как задумано.