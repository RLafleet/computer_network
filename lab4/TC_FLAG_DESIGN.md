# Обработка TC-флага в итеративном DNS-резолвере

## Контекст
При работе по UDP размер классического DNS-ответа ограничен 512 байтами. Если сервер не может уместить полный ответ, он возвращает усечённый пакет и устанавливает флаг TC (Truncated) в заголовке. Клиент обязан повторить запрос по TCP, где ограничение размера отсутствует (до 65535 байт с длиной в префиксе), и получить полный ответ.

В рамках итеративного резолвера каждый шаг (запрос к корневому серверу, к NS зоны и т.д.) выполняется одинаково: сначала по UDP, затем — при необходимости — по TCP. Именно этот переход отвечает за корректное разрешение «тяжёлых» типов (TXT, DNSKEY, большие цепочки) и за корректное получение полного набора записей.

## Общий алгоритм шага резолвинга
Ниже описан алгоритм обработки TC-флага для одного DNS-запроса к конкретному серверу. Итеративный резолвер применяет этот шаг на каждом уровне дерева имён, пока не будут получены нужные записи.

1. **Формирование запроса**
   - Собирается DNS-пакет с `RD=0` (итеративный запрос).
   - Заполняется `ID`, `QDCOUNT=1`, имя домена и тип записи.

2. **Отправка по UDP**
   - Создаётся UDP-сокет: `socket(AF_INET/AF_INET6, SOCK_DGRAM, 0)`.
   - Задаются таймауты `SO_RCVTIMEO` и `SO_SNDTIMEO`.
   - Выполняется `connect()` к адресу DNS-сервера и `send()` запроса.
   - Выполняется `recv()` ответа в буфер.

3. **Разбор ответа**
   - Парсится заголовок: `ID`, `RCODE`, количество секций.
   - Если `RCODE != 0`, возвращается ошибка (NXDOMAIN и др.).
   - Проверяется флаг **TC**.

4. **Обработка TC-флага**
   - Если `TC=0`, используется полученный UDP-ответ.
   - Если `TC=1`, то:
     1) Логируется событие перехода (в debug-режиме).
     2) Создаётся TCP-сокет: `socket(AF_INET/AF_INET6, SOCK_STREAM, 0)`.
     3) Устанавливаются таймауты `SO_RCVTIMEO`, `SO_SNDTIMEO`.
     4) Выполняется `connect()`.
     5) Запрос отправляется по TCP с **двухбайтовым префиксом длины**:
        - `uint16_t len = htons(query_len)`
        - `send(len)` затем `send(query)`
     6) Считывается длина ответа (2 байта) и сам ответ `len` байт:
        - `recv(len)` затем `recv(response)`
     7) Ответ разбирается повторно (полный пакет без усечения).

5. **Возврат результата**
   - Если TCP-ответ успешно получен и распарсен — возвращается он.
   - Если TCP-запрос не удался (таймаут/сеть), ошибка отдаётся наверх.

## Псевдокод
```
function query_with_tcp_fallback(server, query):
    resp = udp_send_and_recv(server, query)
    if resp.error:
        return error
    parsed = parse_dns(resp)
    if parsed.TC == 0:
        return parsed

    log("TC flag set, retrying over TCP")
    resp_tcp = tcp_send_and_recv_with_length(server, query)
    if resp_tcp.error:
        return error
    return parse_dns(resp_tcp)
```

## Детали реализации TCP
- TCP использует «length-prefixed» формат: 2 байта длины (big-endian) перед каждым DNS-пакетом.
- При чтении используется функция `recv_all()` для гарантированного получения всех байтов.
- Максимальный размер ответа в реализации ограничен `DNS_MAX_PACKET` (4096 байт), что достаточно для типичных учебных сценариев; при желании можно увеличить.

## Обработка ошибок и таймауты
- На UDP и TCP уровне используются таймауты (например 3 секунды).
- Ошибки сокетов (`connect`, `send`, `recv`) приводят к возврату ошибки на уровень резолвера.
- Резолвер пробует следующий сервер из списка (если есть), чтобы сохранить устойчивость.

## Логирование для отладки
В debug-режиме выводятся ключевые события:
- `Запрос UDP <ip:port>`
- `Установлен флаг TC, повтор по TCP <ip:port>`
- `Ответ <ip:port>: rcode=...`

Таким образом можно наглядно зафиксировать момент смены протокола и подтвердить, что механизм TC корректно отрабатывает.
